#!/usr/bin/env node

/**
 * Ecosystem vulnerability and compatibility checker
 * Checks for known issues, breaking changes, and security vulnerabilities
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const projectRoot = path.join(__dirname, '../../..');

// Known ecosystem vulnerabilities and issues
const ecosystemIssues = {
  nativewind: {
    '2.0.11': {
      issues: [
        'Performance issues with large stylesheets',
        'Incomplete Tailwind CSS 3.x support',
        'Memory leaks in development mode'
      ],
      recommendations: [
        'Upgrade to NativeWind 4.x for better performance',
        'Use styled() wrapper for better tree shaking',
        'Consider CSS-in-JS alternatives for complex animations'
      ],
      breakingChanges: {
        '4.0.0': [
          'className prop behavior changed on Text components',
          'New Metro configuration required',
          'Tailwind CSS 4.x support only'
        ]
      }
    }
  },

  'react-navigation': {
    '7.x': {
      issues: [
        'Memory leaks in nested navigators',
        'TypeScript inference issues with screen params'
      ],
      recommendations: [
        'Use navigation.setParams() instead of route.params mutation',
        'Implement proper screen focus listeners',
        'Use React.memo() for expensive screen components'
      ]
    }
  },

  'expo': {
    '53.x': {
      issues: [
        'Some packages not yet compatible with React Native 0.79',
        'New Architecture (Fabric) not fully supported'
      ],
      recommendations: [
        'Test thoroughly before upgrading to SDK 54',
        'Check expo/expo GitHub for compatibility updates',
        'Use Expo dev build for better debugging'
      ],
      breakingChanges: {
        '54.0.0': [
          'Minimum iOS version increased to 13.4',
          'Some deprecated APIs removed',
          'New Metro configuration required'
        ]
      }
    }
  },

  'react-native-reanimated': {
    '3.17.x': {
      issues: [
        'Performance regression with large datasets',
        'iOS build issues with Xcode 15'
      ],
      recommendations: [
        'Use worklets sparingly for better performance',
        'Implement proper cleanup in useEffect',
        'Consider react-native-skia for complex animations'
      ]
    }
  }
};

// Security vulnerability database (simplified)
const securityVulnerabilities = {
  'async-storage': {
    '< 1.18.0': {
      severity: 'medium',
      description: 'Potential data corruption on Android',
      cve: 'CVE-2022-example',
      fix: 'Upgrade to 1.18.0 or later'
    }
  },
  
  'react-native-webview': {
    '< 13.6.0': {
      severity: 'high', 
      description: 'XSS vulnerability in injected JavaScript',
      cve: 'CVE-2023-example',
      fix: 'Upgrade to 13.6.0 or later'
    }
  }
};

// Compatibility matrix
const compatibilityMatrix = {
  'react-native': {
    '0.79.x': {
      compatible: {
        'expo': '^53.0.0',
        'react-navigation': '^7.0.0',
        'react-native-reanimated': '^3.17.0',
        'react-native-gesture-handler': '^2.24.0'
      },
      incompatible: {
        'nativewind': '^4.0.0',  // Requires RN 0.81+
        'react-native-screens': '^4.15.0'  // Requires newer RN
      }
    }
  },

  'expo': {
    '53.x': {
      requiresExact: {
        'react-native': '0.79.5',
        'react': '19.0.0'
      },
      recommended: {
        'typescript': '^5.8.3',
        '@types/react': '~19.0.10'
      }
    }
  }
};

function checkPackageVulnerabilities(packageJson) {
  const vulnerabilities = [];
  const { dependencies, devDependencies } = packageJson;
  const allDeps = { ...dependencies, ...devDependencies };

  Object.entries(allDeps).forEach(([name, version]) => {
    const cleanVersion = version.replace(/[\^~>=<]/g, '');
    
    if (securityVulnerabilities[name]) {
      Object.entries(securityVulnerabilities[name]).forEach(([vulnVersion, details]) => {
        if (satisfiesVulnerableVersion(cleanVersion, vulnVersion)) {
          vulnerabilities.push({
            package: name,
            currentVersion: version,
            vulnerability: details,
            type: 'security'
          });
        }
      });
    }
  });

  return vulnerabilities;
}

function checkEcosystemIssues(packageJson) {
  const issues = [];
  const { dependencies, devDependencies } = packageJson;
  const allDeps = { ...dependencies, ...devDependencies };

  Object.entries(allDeps).forEach(([name, version]) => {
    const cleanVersion = version.replace(/[\^~>=<]/g, '');
    
    if (ecosystemIssues[name]) {
      Object.entries(ecosystemIssues[name]).forEach(([issueVersion, details]) => {
        if (cleanVersion.startsWith(issueVersion.replace('.x', ''))) {
          issues.push({
            package: name,
            currentVersion: version,
            issues: details.issues,
            recommendations: details.recommendations,
            breakingChanges: details.breakingChanges,
            type: 'ecosystem'
          });
        }
      });
    }
  });

  return issues;
}

function checkCompatibility(packageJson) {
  const incompatibilities = [];
  const { dependencies, devDependencies } = packageJson;
  const allDeps = { ...dependencies, ...devDependencies };

  // Check React Native compatibility
  const rnVersion = allDeps['react-native'];
  if (rnVersion) {
    const cleanRnVersion = rnVersion.replace(/[\^~>=<]/g, '');
    const majorMinor = cleanRnVersion.match(/(\d+\.\d+)/)?.[1];
    
    if (majorMinor && compatibilityMatrix['react-native'][`${majorMinor}.x`]) {
      const matrix = compatibilityMatrix['react-native'][`${majorMinor}.x`];
      
      // Check incompatible packages
      Object.entries(matrix.incompatible || {}).forEach(([pkg, requiredVersion]) => {
        if (allDeps[pkg] && !satisfiesVersion(allDeps[pkg], requiredVersion)) {
          incompatibilities.push({
            package: pkg,
            currentVersion: allDeps[pkg],
            issue: `Incompatible with React Native ${majorMinor}.x`,
            requiredVersion,
            type: 'compatibility'
          });
        }
      });
    }
  }

  // Check Expo compatibility
  const expoVersion = allDeps['expo'];
  if (expoVersion) {
    const cleanExpoVersion = expoVersion.replace(/[\^~>=<]/g, '');
    const major = cleanExpoVersion.match(/(\d+)/)?.[1];
    
    if (major && compatibilityMatrix['expo'][`${major}.x`]) {
      const matrix = compatibilityMatrix['expo'][`${major}.x`];
      
      // Check exact version requirements
      Object.entries(matrix.requiresExact || {}).forEach(([pkg, exactVersion]) => {
        if (allDeps[pkg] && !allDeps[pkg].includes(exactVersion)) {
          incompatibilities.push({
            package: pkg,
            currentVersion: allDeps[pkg],
            issue: `Expo SDK ${major} requires exact version`,
            requiredVersion: exactVersion,
            type: 'exact-version'
          });
        }
      });
    }
  }

  return incompatibilities;
}

function satisfiesVulnerableVersion(currentVersion, vulnPattern) {
  // Simplified version comparison for vulnerability checking
  if (vulnPattern.startsWith('<')) {
    const targetVersion = vulnPattern.substring(2);
    return compareVersions(currentVersion, targetVersion) < 0;
  }
  return false;
}

function satisfiesVersion(currentVersion, requiredVersion) {
  // Simplified version checking
  const cleanCurrent = currentVersion.replace(/[\^~>=<]/g, '');
  const cleanRequired = requiredVersion.replace(/[\^~>=<]/g, '');
  
  return compareVersions(cleanCurrent, cleanRequired) >= 0;
}

function compareVersions(a, b) {
  const partsA = a.split('.').map(Number);
  const partsB = b.split('.').map(Number);
  
  for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
    const partA = partsA[i] || 0;
    const partB = partsB[i] || 0;
    
    if (partA > partB) return 1;
    if (partA < partB) return -1;
  }
  
  return 0;
}

async function runNpmAudit(appPath) {
  try {
    const result = execSync('npm audit --json', { 
      cwd: appPath, 
      encoding: 'utf8',
      stdio: ['pipe', 'pipe', 'ignore'] // Suppress stderr
    });
    
    return JSON.parse(result);
  } catch (error) {
    // npm audit returns non-zero exit code when vulnerabilities found
    try {
      return JSON.parse(error.stdout);
    } catch {
      return { vulnerabilities: {} };
    }
  }
}

async function checkApp(appName) {
  const appPath = path.join(projectRoot, appName);
  const packageJsonPath = path.join(appPath, 'package.json');
  
  if (!fs.existsSync(packageJsonPath)) {
    return null;
  }

  const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
  
  console.log(`\nüîç Checking ${appName}...`);
  
  // Check ecosystem issues
  const ecosystemIssues = checkEcosystemIssues(packageJson);
  const compatibilityIssues = checkCompatibility(packageJson);
  const packageVulns = checkPackageVulnerabilities(packageJson);
  
  // Run npm audit
  console.log(`   üìã Running npm audit...`);
  const auditResults = await runNpmAudit(appPath);
  
  return {
    app: appName,
    packageJson,
    ecosystemIssues,
    compatibilityIssues,
    packageVulnerabilities: packageVulns,
    npmAudit: auditResults
  };
}

function generateReport(results) {
  console.log('\nüìä Ecosystem Health Report\n');
  console.log('‚ïê'.repeat(60));
  
  results.forEach(result => {
    if (!result) return;
    
    console.log(`\nüì± ${result.app.toUpperCase()}`);
    console.log('‚îÄ'.repeat(30));
    
    // Security vulnerabilities
    const totalVulns = result.packageVulnerabilities.length + 
                      Object.keys(result.npmAudit.vulnerabilities || {}).length;
    
    if (totalVulns > 0) {
      console.log(`\nüî¥ Security Issues (${totalVulns}):`);
      
      result.packageVulnerabilities.forEach(vuln => {
        console.log(`   ‚ö†Ô∏è  ${vuln.package}@${vuln.currentVersion}`);
        console.log(`      ${vuln.vulnerability.description}`);
        console.log(`      üîß Fix: ${vuln.vulnerability.fix}`);
      });
      
      // NPM audit results
      if (result.npmAudit.vulnerabilities) {
        Object.entries(result.npmAudit.vulnerabilities).forEach(([name, details]) => {
          console.log(`   ‚ö†Ô∏è  ${name}: ${details.severity} severity`);
        });
      }
    } else {
      console.log('\n‚úÖ No known security vulnerabilities');
    }
    
    // Compatibility issues
    if (result.compatibilityIssues.length > 0) {
      console.log(`\nüü° Compatibility Issues (${result.compatibilityIssues.length}):`);
      result.compatibilityIssues.forEach(issue => {
        console.log(`   ‚ö†Ô∏è  ${issue.package}@${issue.currentVersion}`);
        console.log(`      ${issue.issue}`);
        console.log(`      üîß Required: ${issue.requiredVersion}`);
      });
    } else {
      console.log('\n‚úÖ No compatibility issues detected');
    }
    
    // Ecosystem issues
    if (result.ecosystemIssues.length > 0) {
      console.log(`\nüîµ Ecosystem Issues (${result.ecosystemIssues.length}):`);
      result.ecosystemIssues.forEach(issue => {
        console.log(`   üì¶ ${issue.package}@${issue.currentVersion}`);
        issue.issues.forEach(i => console.log(`      ‚Ä¢ ${i}`));
        console.log(`      üí° Recommendations:`);
        issue.recommendations.forEach(r => console.log(`         - ${r}`));
      });
    } else {
      console.log('\n‚úÖ No ecosystem issues detected');
    }
  });
  
  // Overall recommendations
  console.log('\nüéØ Overall Recommendations:');
  console.log('‚îÄ'.repeat(30));
  console.log('1. üîê Address security vulnerabilities immediately');
  console.log('2. üîß Fix compatibility issues before major updates');
  console.log('3. üìö Review ecosystem issues for performance improvements');
  console.log('4. üß™ Test all changes in development environment first');
  console.log('5. üìñ Check migration guides for major version updates');
  
  console.log('\nüìñ Useful Resources:');
  console.log('‚Ä¢ Expo SDK compatibility: https://docs.expo.dev/versions/latest/');
  console.log('‚Ä¢ React Navigation releases: https://github.com/react-navigation/react-navigation/releases');
  console.log('‚Ä¢ NativeWind migration: https://nativewind.dev/v4/overview');
  console.log('‚Ä¢ Security advisories: https://github.com/advisories');
}

async function main() {
  console.log('üî¨ Starting comprehensive ecosystem vulnerability check...');
  
  const apps = ['instructors-app', 'students-app'];
  const results = [];
  
  for (const app of apps) {
    const result = await checkApp(app);
    if (result) {
      results.push(result);
    }
  }
  
  generateReport(results);
  
  // Check if we should exit with error code
  const hasSecurityIssues = results.some(r => 
    r && (r.packageVulnerabilities.length > 0 || 
          Object.keys(r.npmAudit.vulnerabilities || {}).length > 0)
  );
  
  if (hasSecurityIssues) {
    console.log('\n‚ùå Security vulnerabilities detected!');
    process.exit(1);
  } else {
    console.log('\n‚úÖ Ecosystem health check complete!');
  }
}

if (require.main === module) {
  main().catch(error => {
    console.error('‚ùå Error:', error.message);
    process.exit(1);
  });
}

module.exports = {
  checkPackageVulnerabilities,
  checkEcosystemIssues,
  checkCompatibility,
  ecosystemIssues,
  securityVulnerabilities,
  compatibilityMatrix
};